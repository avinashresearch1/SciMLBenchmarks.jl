---
title: Quorum Sensing Work-Precision Diagrams
author: David Widmann, Chris Rackauckas
---

# Setup

Here we test a model of quorum sensing of Pseudomonas putida IsoF in continuous cultures with constant
delay which was published by K. Buddrus-Schiemann et al. in "Analysis of N-Acylhomoserine Lactone Dynamics in Continuous
Cultures of Pseudomonas Putida IsoF By Use of ELISA and UHPLC/qTOF-MS-derived Measurements
and Mathematical Models", Analytical and Bioanalytical Chemistry, 2014.

```julia
using DelayDiffEq, DiffEqDevTools, DiffEqProblemLibrary.DDEProblemLibrary
DDEProblemLibrary.importddeproblems()

const prob = DDEProblemLibrary.prob_dde_qs
```

Particularly, we are interested in the third, low-level component of the system:

```julia
const sol = solve(prob, MethodOfSteps(Vern9(); max_fixedpoint_iters = 1000);
                  reltol=1e-14, abstol=1e-14, save_idxs=3)
const test_sol = TestSolution(sol)

using Plots
gr()
plot(sol)
```

## Qualitative comparisons

First we compare the quality of the solution's third component for different algorithms, using the default tolerances.

```julia
function qualitative(alg)
  sol = solve(prob, MethodOfSteps(alg); reltol=1e-3, abstol=1e-6, save_idxs=3)
  plot(sol)
  scatter!(sol, denseplot = false)
end
```

### RK methods

```julia
qualitative(BS3())
```

```julia
qualitative(Tsit5())
```

```julia
qualitative(RK4())
```

```julia
qualitative(DP5())
```

```julia
qualitative(DP8())
```

```julia
qualitative(OwrenZen3())
```

```julia
qualitative(OwrenZen4())
```

```julia
qualitative(OwrenZen5())
```

### Rosenbrock methods

```julia
qualitative(Rosenbrock23())
```

```julia
qualitative(Rosenbrock32())
```

```julia
qualitative(Rodas4())
```

```julia
qualitative(Rodas5())
```

### Verner methods

```julia
qualitative(Vern7())
```

```julia
qualitative(Vern9())
```

## Qualitative comparisons

Now we compare these methods quantitatively.

```julia
function buildWorkPrecisionSet(algs, abstols, reltols; kwargs...)
    setups = [Dict(:alg => MethodOfSteps(alg)) for alg in algs]
    names = nameof.(typeof.(algs))

    WorkPrecisionSet(prob, abstols, reltols, setups;
                     names = names, save_idxs = 3, appxsol = test_sol, maxiters = Int(1e5),
                     kwargs...)
end
```

### High tolerances

#### RK methods

We start with RK methods at high tolerances.

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [BS3(), Tsit5(), RK4(), DP5(), OwrenZen3(), OwrenZen4(), OwrenZen5()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :final)
plot(wp)
```

We also compare interpolation errors:

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [BS3(), Tsit5(), RK4(), DP5(), OwrenZen3(), OwrenZen4(), OwrenZen5()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L2)
plot(wp)
```

And the maximal interpolation error:

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [BS3(), Tsit5(), RK4(), DP5(), OwrenZen3(), OwrenZen4(), OwrenZen5()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L∞)
plot(wp)
```

Since the correct solution is in the range of 1e-7, we see that most solutions, even at the lower end of the tested tolerances, always lead to relative maximal interpolation errors of at least 1e-1 (and usually worse). `RK4` performs slightly better with relative maximal errors of at least 1e-2. This matches our qualitative analysis above.

#### Rosenbrock methods

We repeat these tests with Rosenbrock methods, and include `RK4` as reference.

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [Rosenbrock23(), Rosenbrock32(), Rodas4(), RK4()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :final)
plot(wp)
```

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [Rosenbrock23(), Rosenbrock32(), Rodas4(), RK4()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L2)
plot(wp)
```

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [Rosenbrock23(), Rosenbrock32(), Rodas4(), RK4()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L∞)
plot(wp)
```

Out of the tested Rosenbrock methods `Rodas4` and `Rosenbrock23` perform best at high tolerances.

#### Verner methods

Finally we test the Verner methods and include `Rosenbrock23` as reference.

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [Vern6(), Vern7(), Vern8(), Vern9(), Rosenbrock23()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :final)
plot(wp)
```

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [Vern6(), Vern7(), Vern8(), Vern9(), Rosenbrock23()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L2)
plot(wp)
```

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [Vern6(), Vern7(), Vern8(), Vern9(), Rosenbrock23()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L∞)
plot(wp)
```

All in all, at high tolerances `Rodas5` and `Rosenbrock23` are the best methods for solving this stiff DDE.

### Low tolerances

#### Rosenbrock methods

We repeat our tests of Rosenbrock methods `Rosenbrock23` and `Rodas5` at low tolerances:

```julia
abstols = @. 1.0 / 10.0^(8:11)
reltols = @. 1.0 / 10.0^(5:8)
algs = [Rosenbrock23(), Rodas4(), Rodas5()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :final)
plot(wp)
```

```julia
abstols = @. 1.0 / 10.0^(8:11)
reltols = @. 1.0 / 10.0^(5:8)
algs = [Rosenbrock23(), Rodas4(), Rodas5()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L2)
plot(wp)
```

```julia
abstols = @. 1.0 / 10.0^(8:11)
reltols = @. 1.0 / 10.0^(5:8)
algs = [Rosenbrock23(), Rodas4(), Rodas5()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L∞)
plot(wp)
```

Thus at low tolerances `Rodas5` outperforms `Rosenbrock23`.

```julia{echo=false}
using DiffEqBenchmarks
DiffEqBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
