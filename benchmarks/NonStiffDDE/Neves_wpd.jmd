---
title: Neves Work-Precision Diagrams
author: David Widmann, Chris Rackauckas
---

# Model

We study a state-dependent delay differential equation that was published by K. W. Neves, "Automatic integration of functional differential equations: An approach", 1975, and is given by

```math
\begin{align*}
  y_1'(t) &= y_2(t), \\
  y_2'(t) &= - y_2(\exp(1 - y_2(t))) y_2(t)^2 \exp(1 - y_2(t)),
\end{align*}
```

for ``t \in [0.1, 5]`` with history function

```math
\begin{align*}
  \phi_1(t) &= \log t,\\
  \phi_2(t) &= 1 / t,
\end{align*}
```

for ``t \in (0, 0.1]``. The analytical solution for ``t \in [0.1, 5]`` is

```math
\begin{align*}
  y_1(t) &= \log t, \\
  y_2(t) &= 1 / t.
\end{align*}
```

The problem is test problem D1 of W. H. Enright and H. Hayashi, "The evaluation of numerical software for delay differential equations", 1997.

# Setup

```julia; results = "hidden"
using DelayDiffEq, DiffEqDevTools, DiffEqProblemLibrary.DDEProblemLibrary
using Random
Random.seed!(123)

DDEProblemLibrary.importddeproblems()

const prob = prob_dde_DDETST_D1

function buildWorkPrecisionSet(algs, abstols, reltols; kwargs...)
    setups = [Dict(:alg => MethodOfSteps(alg)) for alg in algs]
    names = nameof.(typeof.(algs))

    WorkPrecisionSet(prob, abstols, reltols, setups;
                     names = names, maxiters = Int(1e5), kwargs...)
end
```

## Low order RK methods

### High tolerances

First we compare final errors of solutions with low order RK methods at high tolerances.

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [BS3(), Tsit5(), RK4(), DP5(), OwrenZen3(), OwrenZen4(), OwrenZen5()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :final)
plot(wp)
```

Next we test interpolation errors:

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [BS3(), Tsit5(), RK4(), DP5(), OwrenZen3(), OwrenZen4(), OwrenZen5()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L2)
plot(wp)
```

Both interpolation tests and tests of final error show similar results. `BS3` does quite well but only `OwrenZen4`, `OwrenZen5`, and `RK4` achieve interpolation errors of about 1e-5.

### Low tolerances

We repeat our tests at low tolerances.

```julia
abstols = @. 1.0 / 10.0^(8:11)
reltols = @. 1.0 / 10.0^(5:8)
algs = [BS3(), Tsit5(), RK4(), DP5(), OwrenZen3(), OwrenZen4(), OwrenZen5()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :final)
plot(wp)
```

```julia
abstols = @. 1.0 / 10.0^(8:11)
reltols = @. 1.0 / 10.0^(5:8)
algs = [BS3(), Tsit5(), RK4(), DP5(), OwrenZen3(), OwrenZen4(), OwrenZen5()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L2)
plot(wp)
```

Out of the compared methods, `Tsit5`, `DP5`, and `OwrenZen5` seem to be the best methods for this problem at low tolerances, but also `OwrenZen4` performs similarly well. `OwrenZen5` and `OwrenZen4` can even achieve interpolation errors below 1e-9.

## Lazy interpolants

### High tolerances

We compare the Verner methods, which use lazy interpolants, at high tolerances. As reference we include `OwrenZen4`.

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [Vern6(), Vern7(), Vern8(), Vern9(), OwrenZen4()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :final)
plot(wp)
```

```julia
abstols = @. 1.0 / 10.0^(4:7)
reltols = @. 1.0 / 10.0^(1:4)
algs = [Vern6(), Vern7(), Vern8(), Vern9(), OwrenZen4()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L2)
plot(wp)
```

### Low tolerances

We repeat these tests and compare the Verner methods also at low tolerances.

```julia
abstols = @. 1.0 / 10.0^(8:11)
reltols = @. 1.0 / 10.0^(5:8)
algs = [Vern6(), Vern7(), Vern8(), Vern9(), OwrenZen4()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :final)
plot(wp)
```

```julia
abstols = @. 1.0 / 10.0^(8:11)
reltols = @. 1.0 / 10.0^(5:8)
algs = [Vern6(), Vern7(), Vern8(), Vern9(), OwrenZen4()]

wp = buildWorkPrecisionSet(algs, abstols, reltols; error_estimate = :L2)
plot(wp)
```

It seems `Vern6` and `Vern7` are both well suited for the problem at low tolerances and outperform `OwrenZen4`, whereas at high tolerances `OwrenZen4` is more efficient.

```julia; echo = false
using DiffEqBenchmarks
DiffEqBenchmarks.bench_footer(WEAVE_ARGS[:folder], WEAVE_ARGS[:file])
```
